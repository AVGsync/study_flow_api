Аудит проекта study_flow_api
Дата: 2026-03-01

Краткий вердикт
- Текущий уровень: учебный прототип / ранний MVP.
- Конкурентность для production API в 2026: низкая (примерно 3.5/10).
- Плюсы есть (чистая модульная раскладка, chi, bcrypt, контекст), но есть критичные риски по безопасности, контракту API и эксплуатационным практикам.

Что сделано хорошо
1. Архитектурно разделены слои: app/server, handlers, auth, database, models, security.
2. Используется `chi` и middleware-подход, роутинг читаемый.
3. Пароли хешируются через `bcrypt`, есть проверка старого пароля при смене.
4. Работа с БД идет через `context.Context` (`QueryRowContext`, `ExecContext`).
5. Есть миграция схемы и базовый Makefile.
6. Логирование через `slog`, что соответствует современному стеку Go.

Критичные проблемы (исправлять в первую очередь)
1. Утечка пароля в API-ответах.
   - `internal/models/user.go`: поле `Password` имеет тег `json:"password"`.
   - `internal/handlers/user.go` (`Me`) сериализует всю модель `User` в ответ.
   - Риск: отдача `hashed_password` наружу.
   - Что сделать: разделить DB-модель и API DTO, убрать пароль из JSON полностью (`json:"-"`) и отдавать только безопасные поля.

2. Небезопасная/слабая конфигурация JWT.
   - `configs/apiserver.toml`: секрет в открытом виде (`jwt_secret = "secretkeyaccess"`).
   - `internal/auth/middleware.go`: валидируется подпись, но не проверяются обязательные claims (`exp`, `iss`, `aud`, `nbf`) и их бизнес-логика.
   - Что сделать: хранить секрет в ENV/secret manager, ввести строго типизированные claims, обязательные сроки жизни токена, issuer/audience.

3. Ошибочная семантика HTTP-ошибок в change-password.
   - `internal/handlers/user.go`: любые ошибки из ChangePassword -> `500`.
   - Некорректный старый пароль должен быть `400`/`401`, отсутствие пользователя `404`/`401`, внутренние сбои `500`.
   - Что сделать: ввести typed errors в repository/service слое и маппинг в корректные статус-коды.

4. Нет graceful shutdown и lifecycle-управления сервером/БД.
   - `internal/app/apiserver/apiserver.go`: используется `http.ListenAndServe` без контролируемой остановки.
   - Нет закрытия DB при завершении процесса.
   - Что сделать: `http.Server`, обработка сигналов (`SIGINT/SIGTERM`), `Shutdown(ctx)`, `defer db.Close()`.

5. Отсутствие валидации входа.
   - `Update` и `ChangePassword` не валидируют формат email, длину login, минимальную сложность/длину пароля.
   - Что сделать: слой валидации (например `go-playground/validator` или ручной), лимиты длины и строгие правила.

Серьезные проблемы (P1)
1. Неверный response-контракт в `Update`.
   - Возвращается `updateData` (patch payload), а не актуальная сущность из БД.
   - Часто ожидается `200` + обновленный ресурс или `204 No Content`.

2. Логика репозитория смешана с доменной/бизнес-логикой.
   - `ChangePassword` в repository делает и проверку, и хеширование.
   - Современная практика: repository = только persistence; бизнес-правила в service/use-case слое.

3. Неконсистентные JSON-контракты.
   - `User.Login` -> `json:"username"`, `UserUpdate.Login` -> `json:"login"`.
   - Это ломает предсказуемость API.

4. Технический долг в комментариях/кодировке.
   - В `internal/handlers/user.go` есть «битые» комментарии (mojibake), что ухудшает поддержку.

5. Makefile не production-friendly.
   - `build` сразу запускает бинарь `apiserver`.
   - Нет целей `test`, `lint`, `run`, `migrate-up/down`.

6. `go.mod` с `go 1.25.5`.
   - Для Go обычно указывается major.minor (например `1.25`). Patch в директиве `go` нетипичен и может создавать проблемы совместимости инструментов.

Средние проблемы (P2)
1. В middleware на каждый запрос идет обращение к БД (`FindByID`) для уже валидного JWT.
   - Это увеличивает latency/нагрузку.
   - Нормально делать lookup только при необходимости (или кэш/черный список при revoke-стратегии).

2. Нет observability-базиса.
   - Нет request-id, structured access logs по запросам, метрик (`Prometheus`), health/readiness endpoint.

3. Нет timeouts на HTTP-сервере.
   - Нужно выставить `ReadHeaderTimeout`, `ReadTimeout`, `WriteTimeout`, `IdleTimeout`.

4. Конфиг БД без пула соединений.
   - Нет настроек `SetMaxOpenConns`, `SetMaxIdleConns`, `SetConnMaxLifetime`.

5. Миграция `users` не задает default-генерацию `id`.
   - Сейчас `id UUID PRIMARY KEY` без `DEFAULT gen_random_uuid()`.

Что нормально оставить
1. Общая структура пакетов и направление разделения ответственности.
2. Использование `chi` и отдельного middleware для auth.
3. Использование `bcrypt` как базового стандарта хранения паролей.
4. `slog` как основной логгер.
5. SQL с параметрами (`$1`, `$2`) вместо строковой конкатенации.

Минимальный план, чтобы стать конкурентнее
1. Безопасность API:
   - убрать пароль из JSON и всех ответов,
   - нормализовать обработку auth-ошибок,
   - перенести JWT secret в ENV,
   - добавить валидацию claims и сроков.
2. Контракты и доменная логика:
   - DTO для request/response,
   - единые поля `login`/`email`,
   - service слой между handler и repository.
3. Эксплуатация:
   - graceful shutdown,
   - server timeouts,
   - health endpoint,
   - настройки пула БД.
4. Качество разработки:
   - тесты (unit + handler integration),
   - линтеры (`golangci-lint`),
   - Makefile-цели для test/lint/run/migrate.

Итог
- Проект можно быстро подтянуть до крепкого backend-MVP, но в текущем виде он не готов конкурировать с production-решениями из-за критичных security/API-проблем и отсутствия эксплуатационной зрелости.
- При исправлении пунктов P0/P1 конкурентность заметно вырастет (ориентир до ~6.5-7/10 для MVP-уровня).
